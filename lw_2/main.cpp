/*
    GENERAL:
       1) вводить   исходное   дерево  из  файла  в  понятной  для
    пользователя форме, а не с клавиатуры;
       2) по требованию прользователя показывать дерево на экране;
       3) обрабатывать  дерево  в  оперативной памяти,  а не путем
    многократного обращения к файлу;
       4) обеспечить   возможность   многократных   запросов   без
    повторного запуска программы.

    1. УСЛОВИЕ ЗАДАЧИ:
    Имеется   дерево,   корень    которого    соответствует
    основателю  рода.  Сыновья  каждой  вершины  задают  сыновей и
    дочерей  соответствующего  человека.  Указываются  имена  двух
    человек  (например,  А  и  В).  Сообщить,  какая  из следующих
    ситуаций имеет место:
       1) А предок В;
       2) В предок А;
       3) А и В имеют ближайшего общего предка С (9).

    2. АВТОР:
    Потапенко Максим Владимирович

    3. СРЕДА ВЫПОЛНЕНИЯ
    Clang, MacOS

    4. ИСТОЧНИКИ
    Tree train: https://leetcode.com/problem-list/tree/
*/

#include <iostream>
#include <string>
#include <fstream>

using namespace std;

struct Tree {
    string data;
    vector<Tree*> children; // потенциально неоптимально из-за емкости. Еще можно через список
    Tree* parent = nullptr;
};

void dfs_iterative(Tree* root) {
    std::stack<Tree*> stack;
    stack.push(root);
    while (!stack.empty()) {
        Tree* node = stack.top(); stack.pop();
        // process(node);
        // Добавляем в обратном порядке, если важен порядок (например, слева направо)
        for (auto it = node->children.rbegin(); it != node->children.rend(); ++it) {
            stack.push(*it);
        }
    }
}

int main() {
    return 0;
}
